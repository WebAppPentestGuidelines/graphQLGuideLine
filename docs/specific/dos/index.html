<!doctype html><html lang=ja dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="GraphQL診断ガイドライン"><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://wg1.isog-j.org/graphQLGuideLine/docs/specific/dos/"><meta property="og:site_name" content="GraphQL診断ガイドライン"><meta property="og:title" content="GraphQLによるDoS攻撃"><meta property="og:description" content="GraphQL診断ガイドライン"><meta property="og:locale" content="ja"><meta property="og:type" content="article"><meta property="article:section" content="docs"><meta property="article:modified_time" content="2025-04-30T22:07:57+09:00"><title>GraphQLによるDoS攻撃 | GraphQL診断ガイドライン</title>
<link rel=icon href=/graphQLGuideLine/favicon.png><link rel=manifest href=/graphQLGuideLine/manifest.json><link rel=canonical href=https://wg1.isog-j.org/graphQLGuideLine/docs/specific/dos/><link rel=stylesheet href=/graphQLGuideLine/book.min.a7616cf2799b58bddffce9438e31fdbfc6393687cfc0950a4a17cd1cce7e35f6.css integrity="sha256-p2Fs8nmbWL3f/OlDjjH9v8Y5NofPwJUKShfNHM5+NfY=" crossorigin=anonymous><script defer src=/graphQLGuideLine/fuse.min.js></script><script defer src=/graphQLGuideLine/ja.search.min.42eed0036756e63e3953a1a02a0c89732c05e3fb655febbc27446e477f817f8b.js integrity="sha256-Qu7QA2dW5j45U6GgKgyJcywF4/tlX+u8J0RuR3+Bf4s=" crossorigin=anonymous></script><script defer src=/graphQLGuideLine/sw.min.f3ebcdeb3db8b1531df9a8f7bda198a7aca61f4571317c82d2493af27556ab0e.js integrity="sha256-8+vN6z24sVMd+aj3vaGYp6ymH0VxMXyC0kk68nVWqw4=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/graphQLGuideLine/><span>GraphQL診断ガイドライン</span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=検索 aria-label=検索 maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script><ul><li><a href=/graphQLGuideLine/docs/about_graphql/>GraphQLの概要</a></li><li><a href=/graphQLGuideLine/docs/specific/>GraphQLで起こりやすい問題</a><ul><li><a href=/graphQLGuideLine/docs/specific/introspection_query/>Introspection Query</a></li><li><a href=/graphQLGuideLine/docs/specific/dos/ class=active>GraphQLによるDoS攻撃</a></li><li><a href=/graphQLGuideLine/docs/specific/race_condition/>レースコンディション</a></li></ul></li><li><a href=/graphQLGuideLine/docs/common/>GraphQL特有でない問題</a><ul><li><a href=/graphQLGuideLine/docs/common/injection/>インジェクション系の脆弱性について</a></li><li><a href=/graphQLGuideLine/docs/common/access_control/>不適切なアクセス制御</a></li><li><a href=/graphQLGuideLine/docs/common/default_setting/>危険なデフォルト設定の使用</a></li><li><a href=/graphQLGuideLine/docs/common/cross_site_request_forgeries/>クロスサイトリクエストフォージェリ</a></li></ul></li><li><a href=/graphQLGuideLine/docs/appendix/>Appendix</a><ul><li><a href=/graphQLGuideLine/docs/appendix/tools/>診断に役立つツール</a></li><li><a href=/graphQLGuideLine/docs/appendix/documents/>参考文献</a></li></ul></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/graphQLGuideLine/svg/menu.svg class=book-icon alt=Menu></label><h3>GraphQLによるDoS攻撃</h3><label for=toc-control></label></div></header><article class="markdown book-article"><h1 id=graphqlによるdos攻撃>GraphQLによるDoS攻撃
<a class=anchor href=#graphql%e3%81%ab%e3%82%88%e3%82%8bdos%e6%94%bb%e6%92%83>#</a></h1><h2 id=概要>概要
<a class=anchor href=#%e6%a6%82%e8%a6%81>#</a></h2><p>GraphQLはデータ構造に対するクエリ言語であるため、複数のフィールドを組み合わせて巨大なノードを要求するクエリを発行できます。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-graphql data-lang=graphql><span style=display:flex><span><span style=color:#66d9ef>query</span>{
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>regions</span> (limit: <span style=color:#a6e22e>1000</span>){
</span></span><span style=display:flex><span>		teams (limit: <span style=color:#a6e22e>1000</span>){
</span></span><span style=display:flex><span>			users (limit: <span style=color:#a6e22e>1000</span>) {
</span></span><span style=display:flex><span>				name
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>要求クエリの条件を満たすデータが十分に存在している場合、取得ノード数が指数関数的に増加します。</p><p>また、しばしば再帰的にデータ構造が参照可能な状態になることがあります。</p><p>member コンポーネントは、その所属するチーム情報(team)を取得できます。さらに、teamコンポーネントは、そのチームに所属するメンバーリストを持っています。メンバーリストには最初に指定したメンバー情報を参照できるため、コンポーネントの解決にループが生じます。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-graphql data-lang=graphql><span style=display:flex><span><span style=color:#66d9ef>query</span>{
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>member</span> (id: <span style=color:#a6e22e>1</span>){
</span></span><span style=display:flex><span>		name,
</span></span><span style=display:flex><span>		team {
</span></span><span style=display:flex><span>			teamId,
</span></span><span style=display:flex><span>			teamName,
</span></span><span style=display:flex><span>			memberList {
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>...</span>member
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-graphql data-lang=graphql><span style=display:flex><span><span style=color:#66d9ef>query</span>{
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>member</span>{
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>...</span>memberFragment
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fragment</span> <span style=color:#a6e22e>memberFragment</span> <span style=color:#66d9ef>on</span> Member {
</span></span><span style=display:flex><span>	name
</span></span><span style=display:flex><span>	teamFragment
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fragment</span> <span style=color:#a6e22e>teamFragment</span> <span style=color:#66d9ef>on</span> Member {
</span></span><span style=display:flex><span>	team {
</span></span><span style=display:flex><span>		teamId,
</span></span><span style=display:flex><span>		teamName,
</span></span><span style=display:flex><span>		memberList {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>...</span>memberFragment
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span></code></pre></div><p>実際に報告された事例は少ないですが、再帰的な解決を引き起こすクエリは潜在的に脆弱になりうる要素の1つとして指摘されています。</p><p>次のクエリは、Fragmentを使用して無限大のクエリを発行する可能性のあるケースです。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-graphql data-lang=graphql><span style=display:flex><span><span style=color:#66d9ef>query</span>{
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>car</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>...</span>nameFragment
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fragment</span> <span style=color:#a6e22e>nameFragment</span> <span style=color:#66d9ef>on</span> Car {
</span></span><span style=display:flex><span>	name
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>...</span>BrandFragment
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fragment</span> <span style=color:#a6e22e>brandFragment</span> <span style=color:#66d9ef>on</span> Car{
</span></span><span style=display:flex><span>	brand
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>...</span>nameFragment
</span></span></code></pre></div><p>以下は、サーバ側では無限大のサイズを持ったクエリに展開されます。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-graphql data-lang=graphql><span style=display:flex><span><span style=color:#66d9ef>query</span>{
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>car</span>{
</span></span><span style=display:flex><span>	  name, brand, name, brand, name, brand, name, brand, name, brand, <span style=color:#66d9ef>...</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>また、データを取得するQuery宣言だけでなく、データの登録・更新・削除等データに対する副作用をもつMutation宣言でも起こりうる問題です。特に処理時間の長いミューテーションを同時実行することにより容易にサーバに対して過剰な負荷をかけることが可能になる場合があります。</p><h2 id=影響>影響
<a class=anchor href=#%e5%bd%b1%e9%9f%bf>#</a></h2><p>このような再帰的な解決を引き起こすクエリは、クエリ展開やオブジェクト解決にリソースが専有されます。その結果、サーバに過剰な負荷をかけることでレスポンス時間の遅延や、最悪の場合サーバダウンを引き起こす可能性があります。</p><h2 id=検証方法>検証方法
<a class=anchor href=#%e6%a4%9c%e8%a8%bc%e6%96%b9%e6%b3%95>#</a></h2><h3 id=データ構造の再帰的解決が発生する箇所の発見>データ構造の再帰的解決が発生する箇所の発見
<a class=anchor href=#%e3%83%87%e3%83%bc%e3%82%bf%e6%a7%8b%e9%80%a0%e3%81%ae%e5%86%8d%e5%b8%b0%e7%9a%84%e8%a7%a3%e6%b1%ba%e3%81%8c%e7%99%ba%e7%94%9f%e3%81%99%e3%82%8b%e7%ae%87%e6%89%80%e3%81%ae%e7%99%ba%e8%a6%8b>#</a></h3><p>データ構造をグラフ化することで、データどうしの関係を可視化し、解決がループしていないかを容易に探すことができます。</p><p>&ldquo;GraphQL Voyager&rdquo;[2] はGraphQLのSDLやIntrospectionを読み込むことで、データ構造の関係図を作成するツールです。解決先のデータ構造を矢印で示します。</p><center><figure><img src=../figure1.png alt=図1 width=60%><figcaption><p>図1</p></figcaption></figure></center><p>図1.は、GraphQL Voyagerのライブデモのスキーマを用いて作成したものです。AuthorはBookオブジェクトを持っており、クエリ内に含まれている場合はBookも同時に解決されます。しかし、BookはAuthorオブジェクトを持っており、双方でデータ構造の解決にループが生じていることが確認できます。</p><h3 id=解決をループさせるクエリの作成>解決をループさせるクエリの作成
<a class=anchor href=#%e8%a7%a3%e6%b1%ba%e3%82%92%e3%83%ab%e3%83%bc%e3%83%97%e3%81%95%e3%81%9b%e3%82%8b%e3%82%af%e3%82%a8%e3%83%aa%e3%81%ae%e4%bd%9c%e6%88%90>#</a></h3><p>実際に再帰的解決を起こすクエリを作成し、レスポンスタイムを比較します。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-graphql data-lang=graphql><span style=display:flex><span><span style=color:#66d9ef>query</span>{
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Author</span> (id: <span style=color:#a6e22e>1</span>){
</span></span><span style=display:flex><span>        name,
</span></span><span style=display:flex><span>        books{
</span></span><span style=display:flex><span>            name,
</span></span><span style=display:flex><span>            author{
</span></span><span style=display:flex><span>                books{
</span></span><span style=display:flex><span>                    name,
</span></span><span style=display:flex><span>                    author{
</span></span><span style=display:flex><span>                        name
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>上記クエリは再帰的解決を発生させる擬似的なクエリの例です。ネストを深く作成することで、より多くのループを発生させることができます。サーバへの影響を考慮しながらネストの深さを徐々に増やしていきます。ネストを深くするに従って、データを返却する時間が長くなっていくことを確認していきます。</p><h3 id=クエリ展開>クエリ展開
<a class=anchor href=#%e3%82%af%e3%82%a8%e3%83%aa%e5%b1%95%e9%96%8b>#</a></h3><p>非常に長いクエリを発行することで、影響を擬似的に調査できます。直接無限大のサイズに展開されうるクエリを発行することで直接影響を確認できますが、サーバが高負荷な状態になる可能性があります。検証する際は検証専用サーバの準備や関係者への周知の上実施するようにしてください。</p><h3 id=limit値の検証>Limit値の検証
<a class=anchor href=#limit%e5%80%a4%e3%81%ae%e6%a4%9c%e8%a8%bc>#</a></h3><p>データの取得件数を指定できる値を徐々に大きくしてレスポンスタイムを計測します。システムが制御しきれない大きさのデータを取り扱うように制御できるかを検証します。データの取得件数を示す変数はシステムによって異なるため、仕様を参照することを推奨します。</p><h2 id=対策>対策
<a class=anchor href=#%e5%af%be%e7%ad%96>#</a></h2><p>次の複数の対策を実施することでDoSに対するリスクを減らすことができます。</p><h3 id=再帰的解決が可能なクエリを排除する>再帰的解決が可能なクエリを排除する
<a class=anchor href=#%e5%86%8d%e5%b8%b0%e7%9a%84%e8%a7%a3%e6%b1%ba%e3%81%8c%e5%8f%af%e8%83%bd%e3%81%aa%e3%82%af%e3%82%a8%e3%83%aa%e3%82%92%e6%8e%92%e9%99%a4%e3%81%99%e3%82%8b>#</a></h3><p>再帰的解決するようなスキーマの設計を極力排除します。しかしながら設計上、再帰的解決が可能なスキーマ構成を採用せざるを得ない場合は以下に示す対策も併せて実施してください。</p><h3 id=クエリの展開深度の最大値を設定する>クエリの展開深度の最大値を設定する
<a class=anchor href=#%e3%82%af%e3%82%a8%e3%83%aa%e3%81%ae%e5%b1%95%e9%96%8b%e6%b7%b1%e5%ba%a6%e3%81%ae%e6%9c%80%e5%a4%a7%e5%80%a4%e3%82%92%e8%a8%ad%e5%ae%9a%e3%81%99%e3%82%8b>#</a></h3><p>クエリの展開深度の最大値を指定することで再帰的解決によるDoS攻撃を防ぐことができます。</p><p>たとえば、GraphQLライブラリの1つである &ldquo;LightHouse&rdquo; では max_query_depth を設定することでクエリのネストの深さを制限できます。しかし、GraphQLを使用するメリットはネストされたデータ構造を単一のリクエストで処理できることです。過度な深さの制限はGraphQLの利便性を否定することになるため、制限を意識することのない範囲かつサーバが処理可能な適切な値を設定する必要があります。</p><p>ライブラリを利用せずに実装している場合、クエリの深さの制限機能が実装されていない場合があります。クエリを実行する前にクエリの深さを検証し、許容値を超えた場合は処理を中断するように実装することを推奨します。</p><h3 id=クエリの複雑さを制限する>クエリの複雑さを制限する
<a class=anchor href=#%e3%82%af%e3%82%a8%e3%83%aa%e3%81%ae%e8%a4%87%e9%9b%91%e3%81%95%e3%82%92%e5%88%b6%e9%99%90%e3%81%99%e3%82%8b>#</a></h3><p>クエリの複雑さを計算し、しきい値を超えたクエリは処理を中断するといった対策も有効です。</p><p>複雑さには推定解決ノードやあらかじめ定義されたコスト値から算出する方法等がありますが、使用言語によっては複雑さ計算によって処理を制限するライブラリが存在します。</p><h3 id=同時実行数を制限する>同時実行数を制限する
<a class=anchor href=#%e5%90%8c%e6%99%82%e5%ae%9f%e8%a1%8c%e6%95%b0%e3%82%92%e5%88%b6%e9%99%90%e3%81%99%e3%82%8b>#</a></h3><p>クエリやミューテーション等の同時実行数を制限することでシステムに過度な負荷をかけることを避けることができます。クエリの展開深度の制限と同様に、過度な制限はGraphQLのメリットを失うことになるため、稼働サーバに適した制限値を選択する必要があります。</p><p>クエリの解決にタイムアウトを設定することで、必要以上にサーバのリソースを消費することを避けることができます。また、クエリの解決回数をカウントしていき、しきい値を超えた場合に処理を中断するといった対策方法も有効です。</p><p>しきい値は運用するサーバの性能や提供サービスによって適切な値を設定してください。</p><p>[1]. <a href=https://spec.graphql.org/July2015/#sec-Fragment-spreads-must-not-form-cycles>https://spec.graphql.org/July2015/#sec-Fragment-spreads-must-not-form-cycles</a></p><p>[2]. <a href=https://github.com/APIs-guru/graphql-voyager>https://github.com/APIs-guru/graphql-voyager</a></p><p>[3]. <a href=https://docs.github.com/ja/graphql/overview/resource-limitations>https://docs.github.com/ja/graphql/overview/resource-limitations</a></p></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/WebAppPentestGuidelines/graphQLGuideLine/commit/89a706ad5dbc5767d105e6ab2bc460674b43149c title='最終更新者 wild0ni0n | 2025年4月30日' target=_blank rel=noopener><img src=/graphQLGuideLine/svg/calendar.svg class=book-icon alt>
<span>2025年4月30日</span></a></div><div><a class="flex align-center" href=https://github.com/WebAppPentestGuidelines/graphQLGuideLine/edit/main/content/docs/specific/dos.md target=_blank rel=noopener><img src=/graphQLGuideLine/svg/edit.svg class=book-icon alt>
<span>このページを編集する</span></a></div></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div></main></body></html>