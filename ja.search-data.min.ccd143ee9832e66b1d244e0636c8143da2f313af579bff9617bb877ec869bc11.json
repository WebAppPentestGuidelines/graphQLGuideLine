[{"id":0,"href":"/graphQLGuideLine/docs/specific/introspection_query/","title":"Introspection Query","section":"GraphQLで起こりやすい問題","content":" Introspection Query # 概要 # Introspectionとは、GraphQLがどのようなスキーマ情報をサポートしているのかを問い合わせるための機能です。主にAPIのリファレンス代わりとして使われており、詳細なドキュメントがなくとも呼び出し方や戻り値、引数等を把握できます。\nGraphQLの多くの実装では、デフォルトでIntrospectionが有効になっており、認証を必要とせずに本機能を利用できます。\n影響 # 攻撃者にこの機能を悪用されると、対象のGraphQLに関する情報を取得され、ほかの脆弱性への攻撃につながってしまう可能性があります。\n実際に報告された事例 # https://hackerone.com/reports/291531 https://hackerone.com/reports/969456 https://hackerone.com/reports/862835 検証方法 # 以下のようなクエリをエンドポイントに送信します。\nquery IntrospectionQuery { __schema { types { name } } } { \u0026#34;data\u0026#34;: { \u0026#34;__schema\u0026#34;: { \u0026#34;types\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;Query\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;String\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;ID\u0026#34; }, (...中略...) { \u0026#34;name\u0026#34;: \u0026#34;__DirectiveLocation\u0026#34; } ] } } } 上記クエリを送信し、正常にqueryTypeを含むレスポンスが返された場合、Introspection Queryが解釈されている可能性があります。このような情報からGraphQLシステムに存在する型の情報やQuery/Mutationの名前、それらを呼び出すのに必要な引数等の情報が取得できます。\nなお、Introspection Queryで定義されているフィールドや、そのレスポンスについての詳細はGraphQL公式ドキュメントを参照してください。\n対策 # Introspection Queryを無効化することを推奨します。\nIntrospectionはAPI作成者がAPI情報を提供する目的で意図的に有効化している可能性もありますが、本番環境ではこの機能を有効とせずにドキュメント等の別の方法で情報を共有してください。\n具体的な無効化の方法については各GraphQLライブラリによって異なるため、ドキュメントを参照してください。\n"},{"id":1,"href":"/graphQLGuideLine/docs/common/injection/","title":"インジェクション系の脆弱性について","section":"GraphQL特有でない問題","content":" インジェクション系の脆弱性について # 概要 # GraphQLサーバで、受け取ったデータを適切にエスケープまたはエンコードせずに、ほかの処理系に渡した場合、インジェクション攻撃が成立し得ます。\n影響 # インジェクションを受けた処理系に応じてさまざまな影響を受けます。\nGraphQLで受け取った入力を渡す先の処理系には、たとえば下記のようなものが想定されます。\nOS DBMS(SQL/NoSQL) XMLパーサ このような処理系に信頼できない入力を渡した場合、下記のような攻撃が成立し得ます。\nOSコマンドインジェクション SQL/NoSQLインジェクション XXE(XML External Entity) 他にも、さまざまなインジェクション系の脆弱性につながる可能性があります。例で挙げたような処理系以外でも、GraphQLサーバが受け取った入力を渡す場合は、適切にその入力値を処理する必要があります。\n検証方法 # 実際に、例を見てGraphQLを利用したアプリケーションでSQLインジェクションが成立することを確認しましょう。下記のようなGraphQLのスキーマを想像してください。\ntype Article { id: ID title: String content: String } type Query { # 記事の情報を取得する getArticle(id: ID): Article } スキーマで定義されたクエリgetArticleのリゾルバは下記のように実装されているとします。(サンプルコードは擬似コードです。)\nfunc getArticleResolver(id: string) { return query(\u0026#34;SELECT * FROM users WHERE id = \u0026#34; + id); } このとき、ユーザーが下記のようなGraphQLクエリを投げた場合のSQLクエリを考えてみてください。\nquery { getArticle(id: \u0026#34;1 UNION SELECT * FROM users\u0026#34;) { id title content } } 実際に発行されるSQLクエリは、開発者が意図していたものとは異なるものになることがわかります。具体的には、SELECT * FROM users WHERE id = 1 UNION SELECT * FROM usersというSQLクエリが発行されます。\nこのように、GraphQLを使用していてもリゾルバで危険なSQLクエリの組み立て方をしていれば、SQLインジェクションの脆弱性につながります。\n対策 # GraphQLサーバが受け取った入力をほかの処理系で利用する場合には、その入力値を必ず適切にエスケープまたはエンコードしてください。また、一般的なインジェクション対策と同様に、入力値のバリデーションも保険的対策として有効です。\n各インジェクション系の脆弱性の対策については、ここでの説明は省略します。各インジェクション系の脆弱性の対策について、より詳しい情報が必要であれば下記のようなページをご参照ください。\nOS Command Injection Defense - OWASP Cheat Sheet Series SQL Injection Prevention - OWASP Cheat Sheet Series What is NoSQL Injection and How Can You Prevent It? | Invicti XXE Injection Prevention - OWASP Cheat Sheet Series XML Security - OWASP Cheat Sheet Series "},{"id":2,"href":"/graphQLGuideLine/docs/appendix/tools/","title":"診断に役立つツール","section":"Appendix","content":" 診断に役立つツール # GraphQL クライアント # GraphQLに対応したクライアントを利用することで、対象のGraphQL構成の把握や調査に役立ちます。プロキシツールと併用することで手動での検査をする際にも有用です。\nAltair https://altair.sirmuel.design/ Insomnia https://insomnia.rest/products/insomnia GraphiQL https://github.com/graphql/graphiql graphql-voyager https://github.com/APIs-guru/graphql-voyager プロキシツール # Webアプリケーション一般のデバッグや脆弱性診断によく用いられる、HTTPレベルでの操作をしやすくするためのツールです。\nBurp Suite https://portswigger.net/burp Fiddler https://www.telerik.com/fiddler OWASP ZAP https://www.zaproxy.org/ Packet Proxy https://github.com/DeNA/PacketProxy 学習サイト/環境 # GraphQLに関係した脆弱性について学べるサイトやツールは、攻撃者視点でWebアプリケーションを見る上で有用です。\nDamn-Vulnerable-GraphQL-Application(DVGA) https://github.com/dolevf/Damn-Vulnerable-GraphQL-Application hacker101 https://www.hackerone.com/hackers/hacker101 自動スキャンツール # 手動で見つけられない脆弱性を機械的に探す場合や、網羅的に探す場合に有用です。\ninQL (Burp Suite Extender) Webアプリケーションの診断でよく用いられるBurpにおいて、GraphQLの診断をサポートしてくれるExtensionです。\nhttps://github.com/doyensec/inql\nOWASP ZAP Addon オープンソースで提供されているWebアプリケーション診断ツールであるOWASP ZAPにおいて、GraphQLの診断をサポートしてくれるAddonです。\nhttps://github.com/zaproxy/zap-extensions/tree/main/addOns/graphql\nGraphQLmap スキーマのダンプやファジングが可能な、侵入テストの目的でGraphqlエンドポイントと対話するためのスクリプトエンジンです。\nhttps://github.com/swisskyrepo/GraphQLmap\ngraphql-path-enum スキーマやタイプを特定するためのさまざまな方法をリストするツールです。\nhttps://gitlab.com/dee-see/graphql-path-enum\n"},{"id":3,"href":"/graphQLGuideLine/docs/specific/dos/","title":"GraphQLによるDoS攻撃","section":"GraphQLで起こりやすい問題","content":" GraphQLによるDoS攻撃 # 概要 # GraphQLはデータ構造に対するクエリ言語であるため、複数のフィールドを組み合わせて巨大なノードを要求するクエリを発行できます。\nquery{ regions (limit: 1000){ teams (limit: 1000){ users (limit: 1000) { name } } } } 要求クエリの条件を満たすデータが十分に存在している場合、取得ノード数が指数関数的に増加します。\nまた、しばしば再帰的にデータ構造が参照可能な状態になることがあります。\nmember コンポーネントは、その所属するチーム情報(team)を取得できます。さらに、teamコンポーネントは、そのチームに所属するメンバーリストを持っています。メンバーリストには最初に指定したメンバー情報を参照できるため、コンポーネントの解決にループが生じます。\nquery{ member (id: 1){ name, team { teamId, teamName, memberList { ...member } } } } query{ member{ ...memberFragment } } fragment memberFragment on Member { name teamFragment } fragment teamFragment on Member { team { teamId, teamName, memberList { ...memberFragment } } 実際に報告された事例は少ないですが、再帰的な解決を引き起こすクエリは潜在的に脆弱になりうる要素の1つとして指摘されています。\n次のクエリは、Fragmentを使用して無限大のクエリを発行する可能性のあるケースです。\nquery{ car { ...nameFragment } } fragment nameFragment on Car { name ...BrandFragment } fragment brandFragment on Car{ brand ...nameFragment 以下は、サーバ側では無限大のサイズを持ったクエリに展開されます。\nquery{ car{ name, brand, name, brand, name, brand, name, brand, name, brand, ... } } また、データを取得するQuery宣言だけでなく、データの登録・更新・削除等データに対する副作用をもつMutation宣言でも起こりうる問題です。特に処理時間の長いミューテーションを同時実行することにより容易にサーバに対して過剰な負荷をかけることが可能になる場合があります。\n影響 # このような再帰的な解決を引き起こすクエリは、クエリ展開やオブジェクト解決にリソースが専有されます。その結果、サーバに過剰な負荷をかけることでレスポンス時間の遅延や、最悪の場合サーバダウンを引き起こす可能性があります。\n検証方法 # データ構造の再帰的解決が発生する箇所の発見 # データ構造をグラフ化することで、データどうしの関係を可視化し、解決がループしていないかを容易に探すことができます。\n\u0026ldquo;GraphQL Voyager\u0026rdquo;[2] はGraphQLのSDLやIntrospectionを読み込むことで、データ構造の関係図を作成するツールです。解決先のデータ構造を矢印で示します。\n図1\n図1.は、GraphQL Voyagerのライブデモのスキーマを用いて作成したものです。AuthorはBookオブジェクトを持っており、クエリ内に含まれている場合はBookも同時に解決されます。しかし、BookはAuthorオブジェクトを持っており、双方でデータ構造の解決にループが生じていることが確認できます。\n解決をループさせるクエリの作成 # 実際に再帰的解決を起こすクエリを作成し、レスポンスタイムを比較します。\nquery{ Author (id: 1){ name, books{ name, author{ books{ name, author{ name } } } } } } 上記クエリは再帰的解決を発生させる擬似的なクエリの例です。ネストを深く作成することで、より多くのループを発生させることができます。サーバへの影響を考慮しながらネストの深さを徐々に増やしていきます。ネストを深くするに従って、データを返却する時間が長くなっていくことを確認していきます。\nクエリ展開 # 非常に長いクエリを発行することで、影響を擬似的に調査できます。直接無限大のサイズに展開されうるクエリを発行することで直接影響を確認できますが、サーバが高負荷な状態になる可能性があります。検証する際は検証専用サーバの準備や関係者への周知の上実施するようにしてください。\nLimit値の検証 # データの取得件数を指定できる値を徐々に大きくしてレスポンスタイムを計測します。システムが制御しきれない大きさのデータを取り扱うように制御できるかを検証します。データの取得件数を示す変数はシステムによって異なるため、仕様を参照することを推奨します。\n対策 # 次の複数の対策を実施することでDoSに対するリスクを減らすことができます。\n再帰的解決が可能なクエリを排除する # 再帰的解決するようなスキーマの設計を極力排除します。しかしながら設計上、再帰的解決が可能なスキーマ構成を採用せざるを得ない場合は以下に示す対策も併せて実施してください。\nクエリの展開深度の最大値を設定する # クエリの展開深度の最大値を指定することで再帰的解決によるDoS攻撃を防ぐことができます。\nたとえば、GraphQLライブラリの1つである \u0026ldquo;LightHouse\u0026rdquo; では max_query_depth を設定することでクエリのネストの深さを制限できます。しかし、GraphQLを使用するメリットはネストされたデータ構造を単一のリクエストで処理できることです。過度な深さの制限はGraphQLの利便性を否定することになるため、制限を意識することのない範囲かつサーバが処理可能な適切な値を設定する必要があります。\nライブラリを利用せずに実装している場合、クエリの深さの制限機能が実装されていない場合があります。クエリを実行する前にクエリの深さを検証し、許容値を超えた場合は処理を中断するように実装することを推奨します。\nクエリの複雑さを制限する # クエリの複雑さを計算し、しきい値を超えたクエリは処理を中断するといった対策も有効です。\n複雑さには推定解決ノードやあらかじめ定義されたコスト値から算出する方法等がありますが、使用言語によっては複雑さ計算によって処理を制限するライブラリが存在します。\n同時実行数を制限する # クエリやミューテーション等の同時実行数を制限することでシステムに過度な負荷をかけることを避けることができます。クエリの展開深度の制限と同様に、過度な制限はGraphQLのメリットを失うことになるため、稼働サーバに適した制限値を選択する必要があります。\nクエリの解決にタイムアウトを設定することで、必要以上にサーバのリソースを消費することを避けることができます。また、クエリの解決回数をカウントしていき、しきい値を超えた場合に処理を中断するといった対策方法も有効です。\nしきい値は運用するサーバの性能や提供サービスによって適切な値を設定してください。\n[1]. https://spec.graphql.org/July2015/#sec-Fragment-spreads-must-not-form-cycles\n[2]. https://github.com/APIs-guru/graphql-voyager\n[3]. https://docs.github.com/ja/graphql/overview/resource-limitations\n"},{"id":4,"href":"/graphQLGuideLine/docs/about_graphql/","title":"GraphQLの概要","section":"Docs","content":" GraphQLの概要 # GraphQLとは # GraphQLとはFacebookによって開発されたWeb APIの規格です。\nRESTful APIにおける課題を解決する技術として注目されており、海外ではGitHub,Twitter等すでに多くのサービスで採用され、近年では国内でも採用するサービスが増えてきました。\nGraphQLの例 # GraphQLはSQLのようなデータを問い合わせるための言語であり、以下2つの言語が存在します。\nクエリ： GraphQL API のリクエストを生成するための言語 スキーマ： GraphQL API の仕様を記述するための言語 ここでは、ユーザー情報を通知するようなGraphQLサービスを例としてGraphQLの処理を簡単に説明します。\nこのサービスでは、サーバ側で以下のような内容のスキーマが定義されています。\ntype Query { user: User } type User { id: ID name: String mail: String } このスキーマではuserというクエリで、Userというオブジェクトを取得することを定義しています。スキーマの記述内容を簡単に説明すると以下となります。\ntype Queryはqueryのためにあらかじめ予約されたルート型名であり、フィールドUserを持っています。 同様にtype UserはID型であるidフィールド、String型であるnameフィールドとmailフィールドを持っています。 GraphQLでは、クライアント側は処理させたいクエリ指定してリクエストを送信します。クライアント側から以下のようなユーザーの名前を取得するようなクエリが記述されたリクエストを受信したとします。\nquery { user { name } } サーバはリクエストを受け取ると送信されてきたクエリを上記で説明した定義済みのスキーマに照合して検証し、クエリを実行します。その後、クライアントはレスポンスでjson形式のクエリが処理された結果を受け取ります。\n{ \u0026#34;data\u0026#34;: { \u0026#34;user\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;Shindan Taro\u0026#34; } } } たとえば名前だけではなくメールアドレスも取得したい場合には以下のようにクエリを変更することで取得できます。\nquery { User { name mail } } { \u0026#34;data\u0026#34;: { \u0026#34;User\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;Shindan Taro\u0026#34; \u0026#34;mail\u0026#34;: \u0026#34;taro@example.com\u0026#34; } } } また、GraphQLスキーマを以下のように設定することで、クエリに引数を持たせることもできます。 以下の例ではuserConditionという名前のUserConditionオブジェクトにて、ユーザーIDの値を引数にとるGraphQLスキーマを定義しています。\ntype Query { user(userCondition: UserCondition!): User } type User { id: ID name: String mail: String } input UserCondition { id: ID! } 以下のように引数を伴ったクエリを送信できます。\nquery { user(userCondition: { id: \u0026#34;1\u0026#34; }) { name mail } } このようにクエリを操作することによってクライアント側が欲しい情報の指定が可能であり、一度のリクエストで多くのリソースを取得できることが特徴となっています。 また、多数のエンドポイントが必要なRESTful APIと異なり、1つのエンドポイントで済む利点もあります。\n"},{"id":5,"href":"/graphQLGuideLine/docs/appendix/documents/","title":"参考文献","section":"Appendix","content":" 参考文献 # GraphQL公式サイト: https://graphql.org/ ベストプラクティス: https://graphql.org/learn/best-practices/ GraphQL - OWASP Cheat Sheet Series: https://cheatsheetseries.owasp.org/cheatsheets/GraphQL_Cheat_Sheet.html 9 Ways To Secure your GraphQL API — GraphQL Security Checklist: https://www.apollographql.com/blog/graphql/security/9-ways-to-secure-your-graphql-api-security-checklist/ Webアプリケーション診断ガイドライン: https://github.com/ueno1000/WebAppPentestGuidelines "},{"id":6,"href":"/graphQLGuideLine/docs/common/access_control/","title":"不適切なアクセス制御","section":"GraphQL特有でない問題","content":" 不適切なアクセス制御 # 概要 # GraphQL APIにおいても、ほかのシステムと同様に、アクセス制御を適切に実施する必要があります。\n影響 # GraphQL APIのアクセス制御が適切に実施されていない場合、APIで操作できるさまざまなリソース(例：ユーザー情報やライセンスキー等)が、不正に作成、取得、更新、削除される可能性があります。\n昨今では、国内のサービスでもGraphQL APIにおけるアクセス制御の不備が発見され報告されています。詳しくは、下記のページをご覧ください。\nGraphQL採用サービスで任意カラムを取得できる脆弱性を見つけた話 GraphQL採用サービスに追加で脆弱性を報告した話 検証方法 # 対象のリソースに対するアクセス権を持たない認証状態で、クエリやミューテーションを通じて、リソースのCRUD操作を試みてください。たとえば、ユーザーIDやライセンスキーのようなアクセス識別子を送っている場合は、値の追加や変更等の検証する方法があります。操作が成功した場合、適切なアクセス制御が実施されていない事がわかります。\n対策 # RBAC(Role Based Access Control)やほかのアクセス制御のしくみを用いて、リソースにCRUDを実行しようとしているユーザーが、適切な権限を有しているかを必ず検証してください。もし、その操作が正規のユーザーによるものであることを確認できない場合、そのリクエストを拒否するようにしてください。\n"},{"id":7,"href":"/graphQLGuideLine/docs/specific/","title":"GraphQLで起こりやすい問題","section":"Docs","content":" GraphQLで起こりやすい問題 # 前述のような特徴を持ったGraphQLですが、その特徴ゆえに以下のような問題が起こりやすくなくっています。\nIntrospection Query GraphQLによるDoS攻撃 レースコンディション また、Webアプリケーションに共通する脆弱性についても影響を受ける恐れがあります。このうち特に重要なものについては次章で説明します。\n"},{"id":8,"href":"/graphQLGuideLine/docs/common/","title":"GraphQL特有でない問題","section":"Docs","content":" GraphQL特有でない問題 # GraphQLを利用したアプリケーションでも、一般的な脆弱性が作り込まれる可能性は依然としてあります。「一般的な脆弱性」の代表的な例としては、下記のようなものが挙げられます。\nインジェクション系の脆弱性について 不適切なアクセス制御 危険なデフォルト設定の使用 クロスサイトリクエストフォージェリ 他にも、クロスサイトスクリプティングやサーバサイドリクエストフォージェリ等、Webアプリケーション一般に共通する脆弱性等があります。これらについては参考文献等を参考に検証・対策してください。\n"},{"id":9,"href":"/graphQLGuideLine/docs/specific/race_condition/","title":"レースコンディション","section":"GraphQLで起こりやすい問題","content":" レースコンディション # 概要 # レースコンディションとは、複数のプロセスやスレッドから同一のリソースへ同時にアクセスした際に、予期せぬ処理結果が生じる問題です。\n図2\nたとえば、データベースにおいてトランザクションがレコードを読み取り、値を更新する処理を考えます。あるトランザクションの更新処理が終わる前に、別のトランザクションが同じレコードを読み取り、値を更新した場合、最終的なレコードの値が想定とは異なる状態に更新されてしまう可能性があります。\nGraphQLにおいても、対策をしていない場合、QueryやMutationのリクエストを同時に送信された場合等に、レースコンディションの問題につながる危険性があります。\nGraphQLにおいては、仕様上1つのリクエスト中で複数のMutationを発行した場合は順序が保証されています。しかし、複数のリクエストを同時に送信した場合の順序は保証されていないため、サーバ側の実装次第ではレースコンディションの影響を受ける危険性があります。\n影響 # 通常のレースコンディションと同様に、予期せぬ処理結果が生じます。たとえば下記のようなものが想定されます。\nデータの不整合が発生する アクセス制限が回避される 実際に、以下のような事例が報告されています。\nhttps://hackerone.com/reports/488985\nテスト用アカウントのクレデンシャルを取得するmutaitionリクエストを複数送信することにより、本来取得できないはずのアカウントのクレデンシャルを取得可能であった。\n検証方法 # 設計上、競合状態が発生した際の影響が考えられる箇所において、QueryやMutationリクエストをミリ秒単位で同時に複数送信した場合に、処理結果に不整合が発生しないか確認をします。具体的な方法としては、BurpSuiteのIntruderのようなローカルプロキシツールの機能の利用が挙げられます。\nまた、ホワイトボックステストも有効です。データベースやファイル等の共有資源へアクセスする処理では問題が起きやすいため、排他制御が適切に行われているか重点的に確認しましょう。\n対策 # 複数のプロセスやスレッドから同一リソースへアクセスが必要な場合、リソースのチェックから更新までの一連の処理が完了するまで、ほかのプロセスからアクセスできないように排他制御を実装することが推奨されます。\nしかしながら、排他制御の実装によっては、サイトのパフォーマンスにも影響を及ぼす可能性があるため、レースコンディション対策ではより一層注意してください。\n"},{"id":10,"href":"/graphQLGuideLine/docs/common/default_setting/","title":"危険なデフォルト設定の使用","section":"GraphQL特有でない問題","content":" 危険なデフォルト設定の使用 # 概要 # GraphQLライブラリには、デフォルトで開発者向け機能が有効になっている場合があります。\n前述のIntrospection機能が代表例ですが、ほかにもエラーメッセージ中に不必要な情報が出力されることもあります。\n具体的には、Introspection機能がOffであってもSchemaを推測されたり、特定のURLで情報を受け取るがためにEndPointを推測されやすいといった問題が挙げられます。\n影響 # 攻撃者にとって有用なシステムに関する情報を取得される恐れがあります。\nただちに攻撃にはつながらないものの、ほかの攻撃の起点となる恐れがあります。\n検証方法 # 以下のように存在しないクエリを送信した際に、レスポンスエラー中に存在するクエリの情報が出力された場合は、対策が必要です。\n{\u0026#34;query\u0026#34;:\u0026#34;query\\n{\\nsysytem\\n}\u0026#34;} { \u0026#34;errors\u0026#34;: [ { \u0026#34;message\u0026#34;: \u0026#34;Cannot query field \\\u0026#34;system\\\u0026#34; on type \\\u0026#34;Query\\\u0026#34;. Did you mean \\\u0026#34;pastes\\\u0026#34;, \\\u0026#34;paste\\\u0026#34;, \\\u0026#34;systemUpdate\\\u0026#34; or \\\u0026#34;systemHealth\\\u0026#34;?\u0026#34;, \u0026#34;locations\u0026#34;: [ { \u0026#34;line\u0026#34;: 2, \u0026#34;column\u0026#34;: 2 } ] } ] } エラーメッセージの出力に起因する問題は、GraphQLのエラーだけではなく、データベースで生じたエラーの情報等も含まれます。 そのため、バックエンドのシステム全体についてエラーメッセージから有用な情報が得られないか検証する必要があります。このような検証には、ファジングやツールによるスキャンが有用です。\nまた、直接コードを閲覧できる場合は、GraphQLライブラリの設定や受け渡している引数が公式ドキュメントやWebページ等で推奨されている方式であるか確認することも有力な検証方法の1つです。\n対策 # 本番環境ではデバッグモードを有効にしないでください。\nまた、エラーメッセージは極力画面上には出力せず、ファイルやデータベース等に書き出してください。\nEndPoint URLはユーザーにアクセスされるため、一般的にはユーザーに向けて開示されている情報です。しかしながら、ユーザーに広く開示していない場合は単純な機械的アクセスによってEndPointを探索されることを避けるため、変更することを推奨します。\nこれらの設定が適切に行えないライブラリを利用する場合は、直接ユーザーがGraphQLサーバに対してアクセスできないように制限してください。対策の例として、ユーザーからの入力情報に応じてGraphQL EndPointに中継するサーバサイドのプログラムで、ユーザーのアクセス制御を行うことが挙げられます。\nなお、必要な設定はライブラリによって異なるため、使用しているライブラリのドキュメントに従って本番環境向けの設定にする必要があります。\n"},{"id":11,"href":"/graphQLGuideLine/docs/appendix/","title":"Appendix","section":"Docs","content":" Appendix # アプリケーションのセキュリティを向上させるうえで役に立つツールやドキュメントを紹介します。\n診断に役立つツール 参考文献 "},{"id":12,"href":"/graphQLGuideLine/docs/common/cross_site_request_forgeries/","title":"クロスサイトリクエストフォージェリ","section":"GraphQL特有でない問題","content":" クロスサイトリクエストフォージェリ # 概要 # GraphQLサーバの実装不備によってクライアントから送信されるリクエストが十分検証できていない場合、クロスサイトリクエストフォージェリ(CSRF)攻撃に対して脆弱になる可能性があります。\n影響 # CSRFが悪用された場合と同様の影響を受けます。GraphQL スキーマで定義されているMutationのような副作用のある処理では、攻撃者によって設置された罠ページを経由することにより被害者の意図しない処理を実行させられます。お問い合わせ機能や、チャットへの投稿、商品購入のような金銭授受に関わる処理など、影響については悪用される機能によって異なります。\n検証方法 # CSRFの検証方法は一般のWebアプリケーションのテスト方法と同様です。 検査対象のアプリケーションとは異なるオリジンの罠ページを用意し、被害者ユーザーの意図にかかわらずリクエストを送信できるかを検証します。\nTesting for Cross Site Request Forgery That single GraphQL issue that you keep missing 通常、GraphQLのクエリを送信するリクエストのContent-Typeは「application/json」で定義されます。 サーバの実装不備などによってContent-Typeが正しく検証されず、「application/json」以外も受け入れてしまう挙動の場合、CSRFに対して脆弱になる可能性があります。 一例として、以下のような罠を含んだページを閲覧することでリクエストが送信され、サーバ側で受け入れられるかを検証します。\n\u0026lt;body onload=\u0026#34;document.forms[0].submit()\u0026#34;\u0026gt; \u0026lt;form action=\u0026#34;https://[TARGET_DOMAIN]/graphql\u0026#34; method=\u0026#34;POST\u0026#34; enctype=\u0026#34;text/plain\u0026#34;\u0026gt; \u0026lt;textarea name=\u0026#34;\u0026amp;#x71;\u0026amp;#x75;\u0026amp;#x65;\u0026amp;#x72;\u0026amp;#x79;\u0026amp;#x7b;\u0026amp;#x41;\u0026amp;#x6c;\u0026amp;#x6c;\u0026amp;#x42;\u0026amp;#x6f;\u0026amp;#x6f;\u0026amp;#x6b;\u0026amp;#x73;\u0026amp;#x7b;\u0026amp;#x42;\u0026amp;#x6f;\u0026amp;#x6f;\u0026amp;#x6b;\u0026amp;#x73;\u0026amp;#x20;\u0026amp;#x7b;\u0026amp;#x69;\u0026amp;#x64;\u0026amp;#x2c;\u0026amp;#x74;\u0026amp;#x69;\u0026amp;#x74;\u0026amp;#x6c;\u0026amp;#x65;\u0026amp;#x2c;\u0026amp;#x61;\u0026amp;#x75;\u0026amp;#x74;\u0026amp;#x68;\u0026amp;#x6f;\u0026amp;#x72;\u0026amp;#x2c;\u0026amp;#x23;\u0026#34; type=\u0026#34;hidden\u0026#34;\u0026gt;x }}}\u0026lt;/textarea\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/body\u0026gt; この罠サイトは以下のようなリクエストを送信します。\nPOST /graphql HTTP/1.1 Host: [TARGET_DOMAIN] Content-Length: 48 Origin: http://[ATTACKER_DOMAIN] Content-Type: text/plain User-Agent: [UA] Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9 Referer: http://[ATTACKER_DOMAIN] Accept-Encoding: gzip, deflate Accept-Language: ja,en-US;q=0.9,en;q=0.8 Connection: close query{AllBooks{Books {id,title,author,#=x }}} 対策 # 対策についても一般のWebアプリケーションの対策方法と同様です。 CSRFトークンやCookieの二重送信などが基本的な対策方法として挙げられますが、先も述べたように、通常GraphQLリクエストのContent-Typeは「application/json」で定義されます。 そのため、GraphQLのようなアプリケーションはAJAXを用いたクライアントアプリケーションとの結び付きが強く、カスタムリクエストヘッダを用いた対策がしばしば提案されます。 カスタムヘッダを設定したリクエストは同一生成元ポリシーによる制限を受けるため、CSRFの対策に有効です。\nCross-Site Request Forgery Prevention "}]